<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7 Notes</title>

    <link rel="stylesheet" href="../css/regular.css">

    <style>
        body {
            line-height: 1.5;
        }

        img {
            width: 80%;
        }
    </style>
</head>
<body>
    <main>
        <h1>Week 7 Notes & Exercises</h1>

        <h2>Chapter 11: Further Functions</h2>
        <ul>
            <li>Functions are first class objects; they can have properties and methods themselves
                <ul>
                    <li>For example, functions have a "length" property that returns the number of parameters they have</li>
                    <li>The call method can be used to set the value of "this" inside a function to an object that is provided as the first argument
                        <ul>
                            <li class="example">function sayHello() { return `My name is ${ this.name }`; const clark = { name: 'Clark' }; sayHello.call(clark)</li>
                        </ul>
                    </li>
                    <li>You can create your own properties; for ex, you can add a description property that describes what the function does</li>
                </ul>
            </li>

            <li>A useful feature is memoization, which is when you can cache results that take a while to compute into an object so that if the same argument is passed through again, the result will be ready
                <ul>
                    <li><img src="img/memoization.JPG" alt="example of memoization"></li>
                </ul>
            </li>

            <li>You can define IFFE's by placing parentheses at the end of the function definition and placing the entire expression in parentheses
                <ul>
                    <li>(function doThis() { define function })();</li>
                    <li>You can create temporary variables within these functions because they will disappear once the functions are executed</li>
                </ul>
            </li>

            <li>Functions can be redefined as you can make them rewrite themselves
                <ul>
                    <li class="example">function party() {<br>
                        &emsp;console.log('This is the first statement');<br>
                        &emsp;party = function() {<br>
                            &emsp;&emsp;console.log('Second statement');
                        &emsp;}<br>
                    }
                    <ul>
                        <li>When run for the first time, it will log the first statement, but it will log the second statement every time afterwards</li>
                    </ul>
                    </li>
                    <li>Be careful when using this because you will lose properties of the functions once it redefines itself</li>
                </ul>
            </li>

            <li>Recursive functions are useful for when iterative processes are involved
                <ul>
                    <li>A common example is a function that calculates the factorial of a number</li>
                    <li><img src="img/recursivefunctionex.JPG" alt="Example of a recursive function"></li>
                </ul>
            </li>

            <li>Promises don't do anything that can't already be achieved by using callbacks
                <ul>
                    <li>But they help simplify the process and avoid the convoluted code that result from using multiple callbacks</li>
                    <li>When a promise is created, it calls an asynchronous operation and is then <b>pending</b></li>
                    <li>While the operation is taking place, the promise is <b>unsettled</b></li>
                    <li>When the operation is completed, the promise is <b>settled</b></li>
                    <li>There are two different outcomes for when a promise is settled
                        <ul>
                            <li>Resolved - the operation was completed successfully</li>
                            <li>Rejected - the operation didn't work as expected, wasn't completed successfully, or resulted in an error</li>
                            <li>Both outcomes return relevant data, and you can take action based on the outcome of the promise</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Creating closures is like creating an 'inner' function, one that is declared inside another function
                <ul>
                    <li>In doing this, the inner function has full access to the variables declared inside the scope of the outside function</li>
                    <li>They are formed when a function returns another function that maintains access to the variables in the outer function</li>
                </ul>
            </li>

            <li>Calling generator functions doesn't run any of the code in the function, but it returns a Generator object
                <ul>
                    <li>The Generator object can be used to create an iterator that implements a next() method that returns a value every time the next() method is called</li>
                    <li>Define a generator function by putting an asterisk right after the function declaration
                        <ul>
                            <li class="example">function* exampleGenerator(){//code}</li>
                        </ul>
                    </li>
                    <li>Yield is used instead of return because yield will store the value for later use</li>
                </ul>
            </li>

            <h2>Ajax</h2>
            <p>Ajax is a technique that allows web pages to communicate asynchronously with a server, and it dynamically updates web pages without reloading
                <ul>
                    <li>enables data to be sent and received in the bg, as well as portions of a page to be updated in response to user events, while the rest of the program continues to run</li>
                </ul>
            </p>

            <li>Request objects are created using the Request() constructor, and include the following properties
                <ul>
                    <li>enables data to be sent and received in the bg, as well as portions of a page to be updated in response to user events, while the rest of the program continues to run
                        <ul>
                            <li>url - The URL of the requested resource (the only property that is required)</li>
                            <li>method - a string that specifies which HTTP method should be used for the request ('GET' by default)</li>
                            <li>headers - a Headers object that provides details of the request's headers</li>
                            <li>mode - allows you to specify if CORS is used or not (CORS is enabled by default)</li>
                            <li>cache - allows you to specify how the request will use the browser's cache</li>
                            <li>credentials - lets you specify if cookies should be allowed with the request</li>
                            <li>redirect - specifies what to do if the response returns a redirect</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h2>Definitions</h2>
        <ol>
            <li><b>Memoization</b>: A useful feature of function properties and methods, result caching</li>
            <li><b>Immediately Invoked Function Expression</b>: (also IIFE, pronounced 'iffy') an anonymous function that is invoked as soon as it's defined</li>
            <li><b>Recursive functions</b>: a function that invokes itself until a certain condition is met</li>
            <li><b>Promise</b>: represents the future result of an asynchronous operation</li>
            <li><b>Closure</b>: a reference to a variable that was created inside the scope of another function but is then kept alive and used in another part of the program</li>
        </ol>

        <h2>Questions</h2>
        <ul>
            <li>Would you only use the call() and apply() method with objects? Why else would you use it and when?</li>
            <li>Why would you want to define a function only to have it rewrite itself? When is this used in a professional setting?</li>
        </ul>
    </main>
    
    <footer>
        <a href="../index.html">Portfolio Directory</a>
    </footer>

    <script src="../js/dark.js"></script>
</body>
</html>